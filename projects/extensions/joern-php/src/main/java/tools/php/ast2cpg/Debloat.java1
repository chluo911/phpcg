package tools.php.ast2cpg;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

import ast.php.functionDef.FunctionDef;
import ast.php.functionDef.Method;
import ast.php.functionDef.TopLevelFunctionDef;
import cg.FileDependencyCheck;
import cg.PHPCGFactory;
import cg.toTopLevelFile;
import inputModules.csv.csv2ast.ASTUnderConstruction;
import misc.MultiHashMap;

public class Debloat {
	private MultiHashMap<Long, Long> callgraph = new MultiHashMap<Long, Long>();
	private Set<Long> allFunIds = new HashSet<Long>();
	private Set<Long> initialMethodIds = new HashSet<Long>();
	private Set<String> cmds = new HashSet<String>();
	private Set<Long> neededIds = new HashSet<Long>();
	//private Set<Long> unNeededIds = new HashSet<Long>();
	private MultiHashMap<String, Integer> line2remove = new MultiHashMap<String, Integer>();
	private boolean isApplication;
	private Set<Long> magicIds;
	private Set<String> classUsed;
	
	
	Debloat(){
		callgraph = PHPCGFactory.mtd2mtd;
		//initialMethodIds.addAll(PHPCGFactory.topFunIds);
		for(Long topFunid: PHPCGFactory.topFunIds) {
			Long topId = toTopLevelFile.getTopLevelId(topFunid);
			if(!ASTUnderConstruction.idToNode.get(topId).getFlags().equals("TOPLEVEL_FILE")) {
				System.err.println("Fail to find top file for target function "+topId);
				continue;
			}
			TopLevelFunctionDef topFile = (TopLevelFunctionDef) ASTUnderConstruction.idToNode.get(topId);
			String phpPath = topFile.getName();
			phpPath = phpPath.substring(1, phpPath.length()-1);
			phpPath = phpPath.replace("//", "/");
			
			String baseDir = "/home/users/chluo/phpMyAdmin-4.7.0--all-languages/";
			if(FileDependencyCheck.excludeDirs.containsKey(baseDir))
			for(String excludePath: FileDependencyCheck.excludeDirs.get(baseDir)) {
				if(phpPath.contains(excludePath)) {
					System.err.println(phpPath);
					continue;
				}
			}
			initialMethodIds.add(topFunid);
		}
		
		allFunIds = new HashSet<Long>(PHPCGFactory.collectAllFun);
		magicIds = new HashSet<Long>(PHPCGFactory.magicMtdDefs);
		classUsed = new HashSet<String>(PHPCGFactory.classUsed);
		//System.err.println(magicIds);
		//System.err.println(classUsed);
		// TODO, add this commend line
		cmds.add("/home/users/chluo/phpMyAdmin-4.7.0-all-languages/vendor");
		// TODO, add this commend line
		isApplication = true;
	}
	
	public void handle() throws IOException {
		//getNeedDirIds();
		if(!getInitialMethod()) {
			return;
		}
		getNeedIds();
		
		System.err.println("all "+allFunIds.size());
		
		allFunIds.removeAll(neededIds);
		
		System.err.println("unneeded: "+allFunIds.size());
		System.err.println("initial: "+initialMethodIds.size());
		System.err.println("needed "+neededIds.size());
		
		getRemoveLines();
		removeLines(); 
	}
	
	private void getRemoveLines() {
		for(Long unNeedId: allFunIds) {
			String path = getPath(unNeedId);
			FunctionDef funDef = (FunctionDef) ASTUnderConstruction.idToNode.get(unNeedId);
			//System.err.println(funDef);
			int startline = funDef.getChild(2).getLocation().startLine;
			startline=startline+1;
			int endline = funDef.getLocation().endLine;
			if(startline==endline) {
				continue;
			}
			line2remove.add(path, startline);
			line2remove.add(path, endline);
		}
		//System.err.println(line2remove);
	}
	
	private void removeLines() throws IOException {
		for(String path: line2remove.keySet()) {
			List<Integer> lines = line2remove.get(path);
			//Collections.sort(lines);
			File inputFile = new File(path);
			File tempFile = new File("myTempFile.php");
			
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile));
			
			int crtLineno = 0;
			boolean toStart=false;
			String currentLine;
			//String errLine = "$trace = debug_backtrace();\r\n" + 
			//		"	  var_dump(__FILE__);\r\n" + 
			//		"	  var_dump(__FUNCTION__);\r\n" + 
			//		"      print_r( $trace);\r\n" + 
			//		"	  die();";
			String errline = "$trace = debug_backtrace();\r\n "
					+ "print_r('<html><head>    <meta charset=\"utf-8\">    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">    <title>Error, Target Function Has Been Removed</title>    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\">    <style>        * {            font-family: tahoma;        }        div.container .panel {            position: relative !important;        }        div.container {            width: 50% !important;            height: 50% !important;            overflow: auto !important;            margin: auto !important;            position: absolute !important;            top: 0 !important;            left: 0 !important;            bottom: 0 !important;            right: 0 !important;        }    </style></head><body>    <div class=\"container\">        <div class=\"panel panel-danger center\">            <div class=\"panel-heading\" style=\"text-align: left;\"> Error </div>            <div class=\"panel-body\">                <p class=\"text-center\">');\r\n "
					+ "print_r($trace);\r\n" 
					+"print_r('</p>            </div>        </div>    </div></body></html>');";
			
			int i=0;
			while((currentLine = reader.readLine()) != null) {
			    crtLineno++;
			    if(lines.contains(crtLineno)) {
			    	toStart = toStart^true;
			    	i=0;
			    }
			    if(toStart!=true) {
			    	 writer.write(currentLine + System.getProperty("line.separator"));
			    }
			    else {
			    	//i++;
			    	//if(i==1)
			    	//	writer.write(errline + System.getProperty("line.separator"));
			    }
			}
			writer.close(); 
			reader.close();
			
			if(!tempFile.renameTo(inputFile)) {
				System.err.println("Fail to debloat file "+path);
			}
		}
	}
	
	private String getPath(Long FunctionId) {
		String path = new String();
		Long topId = toTopLevelFile.getTopLevelId(FunctionId);
		TopLevelFunctionDef topFile = (TopLevelFunctionDef) ASTUnderConstruction.idToNode.get(topId);
		path = topFile.getName();
		path = path.substring(1, path.length()-1);
		return path;
	}
	
	//get which methods are initially needed
	protected boolean getInitialMethod() {
		for(Long funId: allFunIds) {
			Long topId = toTopLevelFile.getTopLevelId(funId);
			//FunctionDef funNode =  (FunctionDef) ASTUnderConstruction.idToNode.get(funId);
			if(!ASTUnderConstruction.idToNode.get(topId).getFlags().equals("TOPLEVEL_FILE")) {
				System.err.println("Fail to find top file for function "+funId);
				return false;
			}
			TopLevelFunctionDef topFile = (TopLevelFunctionDef) ASTUnderConstruction.idToNode.get(topId);
			String phpPath = topFile.getName();
			phpPath = phpPath.substring(1, phpPath.length()-1);
			//System.err.println(phpPath);
			if(!isApplication && InCmdDir(phpPath) ||
					isApplication && !InCmdDir(phpPath)) {
				System.err.println("CCC"+phpPath);
				initialMethodIds.add(funId);
			}
		}
		for(Long magicId: magicIds) {
			Method mtdDef = (Method) ASTUnderConstruction.idToNode.get(magicId);
			String classKey = ((Method)mtdDef).getEnclosingClass();
			if( !mtdDef.getEnclosingNamespace().isEmpty())
				classKey = mtdDef.getEnclosingNamespace() + "\\" + classKey;
			if(classUsed.contains(classKey)) {
				initialMethodIds.add(magicId);
			}
		}
		return true;
	}
	
	//get all methods an app / a library needs
	private void getNeedIds() {
		Queue<Long> queue = new LinkedList<Long>(initialMethodIds);
		while(!queue.isEmpty()) {
			Long crtId = queue.peek();
			if(callgraph.containsKey(crtId)) {
				Set<Long> calledFuns = new HashSet<Long>(callgraph.get(crtId));
				for(Long calledFun: calledFuns) {
					if(!queue.contains(calledFun) && !neededIds.contains(calledFun)) {
						queue.add(calledFun);
						//System.err.println(crtId+" "+calledFun);
					}
				}
			}
			neededIds.add(queue.poll());
		}
	}
	
	private boolean InCmdDir(String path) {
		String Unified_form_path = path.replace("//", "/");
		for(String cmd: cmds) {
			if(Unified_form_path.startsWith(cmd)) {
				return true;
			}
		}
		return false;
	}
}

